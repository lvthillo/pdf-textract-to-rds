import json
import boto3
import os
import pg8000
from trp import Document


def getJobResults(jobId):
    """
    Get readed pages based on jobId
    """

    pages = []
    textract = boto3.client("textract")
    response = textract.get_document_analysis(JobId=jobId)

    pages.append(response)

    nextToken = None
    if "NextToken" in response:
        nextToken = response["NextToken"]

    while nextToken:
        response = textract.get_document_analysis(JobId=jobId, NextToken=nextToken)
        pages.append(response)
        nextToken = None
        if "NextToken" in response:
            nextToken = response["NextToken"]

    return pages


def convert_row_to_list(row):
    """
    Helper method to convert a row to a list.
    """
    list_of_cells = [cell.text.strip() for cell in row.cells]
    return list_of_cells


def get_connection():
    """
    Method to establish the connection to RDS using IAM Role based authentication.
    """
    try:
        print("Connecting to database")
        client = boto3.client("rds")
        DBEndPoint = os.environ.get("DBEndPoint")
        DatabaseName = os.environ.get("DatabaseName")
        DBUserName = os.environ.get("DBUserName")
        # Generates an auth token used to connect to a db with IAM credentials.
        password = client.generate_db_auth_token(
            DBHostname=DBEndPoint, Port=5432, DBUsername=DBUserName
        )
        # Establishes the connection with the server using the token generated as password
        conn = pg8000.connect(
            host=DBEndPoint,
            user=DBUserName,
            database=DatabaseName,
            password=password,
            ssl_context=True,
        )
        print("Succesful connection!")
        return conn
    except Exception as e:
        print("While connecting failed due to :{0}".format(str(e)))
        return None


def write_dict_to_db(mydict, connection):
    """
    Write dictionary to our invoices table.
    """
    DBTable = os.environ.get("TableName")
    cursor = connection.cursor()
    placeholders = ", ".join(["%s"] * len(mydict))
    columns = ", ".join(mydict.keys())
    sql = "INSERT INTO %s ( %s ) VALUES ( %s )" % (DBTable, columns, placeholders)
    print(sql, mydict.values())
    cursor.execute(sql, list(mydict.values()))
    connection.commit()
    cursor.close()


def lambda_handler(event, _):
    """
    Get Extraction Status, JobTag and JobId from SNS.
    If the Status is SUCCEEDED then create a dict of the values and write those to the RDS database.
    """
    notificationMessage = json.loads(json.dumps(event))["Records"][0]["Sns"]["Message"]

    pdfTextExtractionStatus = json.loads(notificationMessage)["Status"]
    pdfTextExtractionJobTag = json.loads(notificationMessage)["JobTag"]
    pdfTextExtractionJobId = json.loads(notificationMessage)["JobId"]

    print(pdfTextExtractionJobTag + " : " + pdfTextExtractionStatus)

    if pdfTextExtractionStatus == "SUCCEEDED":
        response = getJobResults(pdfTextExtractionJobId)
        doc = Document(response)

    all_values = []

    for page in doc.pages:
        # only take last table for each page (page.tables[-1])
        # on first page there are 2 tables, this will help to take the correct one.
        # on other pages there is only one table.
        for i, row in enumerate(page.tables[-1].rows):
            if i == 0:
                keys = convert_row_to_list(page.tables[-1].rows[0])
            else:
                values = convert_row_to_list(row)
                all_values.append(dict(zip(keys, values)))

    connection = get_connection()
    for dictionary in all_values:
        write_dict_to_db(dictionary, connection)
